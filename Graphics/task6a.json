{"camera":{"position":[0.00008112043893450242,-0.00038502457277354396,0.00215511432294565],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,0,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","showWorldCoordinates":false,"showWireframe":false},"passes":{"Quad":{"R2T":{"shaders":{"vertex":{"source":"//vertex coordinates in world space for the render quad\nattribute vec4 vertex_worldSpace;\n//texture coordinate for this vertex and the render quad\nattribute vec2 textureCoordinate_input;\n\n//texture coordinate needs to be passed on to the R2T fragment shader\nvarying vec2 varyingTextureCoordinate;\n\nuniform float canvasWidth;\nuniform float canvasHeight;\nuniform vec3 cameraPosition;\nuniform mat3 cameraRotation;\nuniform bool isOrthographicProjection;\nuniform float orthographicFOV;\nuniform float perspectiveFOV;\n\nvarying vec3 origin;\nvarying vec3 dir;\n\n//main program for each vertex of the render quad\nvoid main() {\n  float aspectRatio = canvasWidth/canvasHeight;\n  vec3 origin_camSpace, dir_camSpace;\n  if (isOrthographicProjection) {\n    origin_camSpace = vec3(vertex_worldSpace.x * orthographicFOV * aspectRatio, vertex_worldSpace.y * orthographicFOV, 0);\n    dir_camSpace = vec3(0, 0, -1);\n  } else {\n    // perspective projection\n    origin_camSpace = vec3(0);\n    dir_camSpace = vec3(vertex_worldSpace.x * aspectRatio, vertex_worldSpace.y,-1.0/tan(radians(perspectiveFOV)));\n  }\n\n  origin = cameraPosition + cameraRotation * origin_camSpace;\n  dir = normalize(cameraRotation*dir_camSpace);\n\n  gl_Position = vertex_worldSpace;\n  varyingTextureCoordinate = textureCoordinate_input;\n}"},"fragment":{"source":"precision mediump float;\n\nstruct Sphere\n{\n  vec3 centre;\n  float radius;\n  vec3 color;\n};\n\nstruct Plane\n{\n  vec3 point;\n  vec3 normal;\n  vec3 color;\n};\n\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n  int valid;\n};\n\nstruct Intersection {\n  vec3 point;\n  vec3 normal;\n  float u;\n  vec3 color;\n};\n\nuniform mat4 modelMatrix;\nuniform mat4 viewMatrix;\nuniform vec3 lightPos;\n\n//texture coordinates coming from the vertex shader, interpolated through the rasterizer\nvarying vec3 origin;\nvarying vec3 dir;\n\nconst int num_sphere = 6;\nSphere sphere[num_sphere];\nPlane plane;\n\nvoid sphere_intersect(Sphere sphere, Ray ray, inout Intersection inter)\n{\n  float a = pow(length(ray.direction), 2.0);\n  float b = 2.0 * dot(ray.direction, (ray.origin - sphere.centre));\n  float c = pow(length(ray.origin - sphere.centre), 2.0) - pow(sphere.radius, 2.0);\n\n  float disc = pow(b, 2.0) - 4.0 * a * c;\n  if (disc > 0.0) {\n    float u1 = (-b + sqrt(disc)) / (2.0 * a);\n    float u2 = (-b - sqrt(disc)) / (2.0 * a);\n\n    // take the nearest intersection\n    float u = min(u1, u2);\n\n    if (u > 0.0) {\n      inter.point = ray.origin + u * ray.direction;\n      inter.normal = normalize(inter.point - sphere.centre);\n      inter.color = sphere.color;\n      inter.u = u;\n    }\n  }\n}\n\nvoid plane_intersect(Plane plane, Ray ray, inout Intersection inter)\n{\n  float checker_width = 0.2;\n\n  float disc = dot(plane.normal, ray.direction);\n  if (disc != 0.0) {\n    float u = -dot(plane.normal, ray.origin - plane.point) / disc;\n    if (u > 0.0 && (u < inter.u || inter.u < 0.0)) {\n      inter.point = ray.origin + u * ray.direction;\n      inter.normal = plane.normal;\n      if (mod(floor(inter.point.z / checker_width), 2.0) == (mod(floor(inter.point.x / checker_width), 2.0))) {\n        inter.color = plane.color;\n      } else {\n        inter.color = vec3(1.0 - plane.color.x, 1.0 - plane.color.y, 1.0 - plane.color.z);\n      }\n      inter.u = u;\n    }\n  }\n}\n\nvoid calculate_intersection(Ray r, inout Intersection intersection) {\n  // intersecting the given ray between the spheres and the plane\n  for (int i = 0; i < num_sphere; i++) {\n    sphere_intersect(sphere[i], r, intersection);\n  }\n\n  plane_intersect(plane, r, intersection);\n}\n\nvec3 computeShadow(in Intersection inter)\n{\n  float epsillon = 0.001;\n  vec4 totalColor = vec4(0, 0, 0, 0);\n\n  Ray shadowRay;\n  shadowRay.origin = inter.point;\n  shadowRay.direction = normalize(-shadowRay.origin + lightPos);\n  shadowRay.origin += inter.normal * epsillon;\n\n  Intersection sInter;\n  sInter.u = -1.0;\n  calculate_intersection(shadowRay, sInter);\n\n  // if something blocks the ray in the middle then skip it\n  if (sInter.u == -1.0) {\n    vec3 lightvec = -inter.point + lightPos;\n    float d = length(lightvec);\n    lightvec = normalize(lightvec);\n    float attenuation = 1.0 / (0.015 * d * d);\n    vec4 color = attenuation * vec4(inter.color, 1) * max(dot(inter.normal, lightvec), 0.0);\n    totalColor += color;\n  }\n\n  return totalColor.xyz;\n}\n\n//main program for each fragment of the render quad\nvoid main() {\n  sphere[0].centre = vec3(-2.0, 1.5, -3.5);\n  sphere[0].radius = 1.5;\n  sphere[0].color = vec3(0.8,0.8,0.8);\n  sphere[1].centre = vec3(-0.5, 0.0, -2.0);\n  sphere[1].radius = 0.6;\n  sphere[1].color = vec3(0.3,0.8,0.3);\n  sphere[2].centre = vec3(1.0, 0.7, -2.2);\n  sphere[2].radius = 0.8;\n  sphere[2].color = vec3(0.3,0.8,0.8);\n  sphere[3].centre = vec3(0.7, -0.3, -1.2);\n  sphere[3].radius = 0.2;\n  sphere[3].color = vec3(0.8,0.8,0.3);\n  sphere[4].centre = vec3(-0.7, -0.3, -1.2);\n  sphere[4].radius = 0.2;\n  sphere[4].color = vec3(0.8,0.3,0.3);\n  sphere[5].centre = vec3(0.2, -0.2, -1.2);\n  sphere[5].radius = 0.3;\n  sphere[5].color = vec3(0.8,0.3,0.8);\n  plane.point = vec3(0,-0.5, 0);\n  plane.normal = vec3(0, 1.0, 0);\n  plane.color = vec3(0.7);\n\n  Ray ray;\n  ray.origin = origin;\n  ray.direction = normalize((viewMatrix * modelMatrix * vec4(dir, 0.0)).xyz);\n  vec3 output_Color = vec3(0.0, 0.0, 0.0);\n\n  Intersection inter;\n  inter.color = vec3(0, 0, 0);\n  inter.u = -1.0;\n  float k_r = 0.5;\n  float epsillon = 0.0001;\n\n  // main ray tracing loop\n  for (int depth = 0; depth < 42; depth++) {\n    calculate_intersection(ray, inter);\n    /* inter.u is initialized as -1.0, so if it's something \n       other than -1.0, it means there is a hit */\n    if (inter.u != -1.0) {\n      output_Color += pow(k_r, float(depth)) * computeShadow(inter);\n\n      Ray reflectedRay;\n      reflectedRay.origin = inter.point;\n      reflectedRay.direction = normalize(reflect(ray.direction, inter.normal));\n      reflectedRay.origin += reflectedRay.direction * epsillon;\n\n      inter.color = vec3(0.0, 0.0, 0.0);\n      inter.u = -1.0;\n      ray = reflectedRay;\n    } else {\n      // the ray has left the scene\n      break;\n    }\n  }\n\n  gl_FragColor = vec4(output_Color, 1.0);\n}"}},"uniforms":{"value":{"canvasWidth":{"attachment":"Canvas Width"},"canvasHeight":{"attachment":"Canvas Height"},"cameraPosition":{"attachment":"Camera Position"},"cameraRotation":{"attachment":"Camera Rotation"},"isOrthographicProjection":{"attachment":"Orthographic Projection?"},"orthographicFOV":{"attachment":"Orthographic FOV"},"perspectiveFOV":{"attachment":"Perspective FOV"},"modelMatrix":{"value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"viewMatrix":{"value":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"lightPos":{"value":[6,4,3]}}}}}},"output":{"image":"Quad/R2T Pass color"}}