{"camera":{"position":[4.609673519425515,4.738816011293538,52.202167679846035],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","showWorldCoordinates":true},"passes":{"Model":{"base":{"shaders":{"vertex":{"source":"//vertex position in world coordinates\nattribute vec3 vertex_worldSpace;\n//surface normal at the vertex in world coordinates\nattribute vec3 normal_worldSpace;\n//texture coordinates at that vertex\nattribute vec2 textureCoordinate_input;\n\n//model Matrix (Identity in our case)\nuniform mat4 mMatrix;\n//view Matrix\nuniform mat4 vMatrix;\n//projection Matrix\nuniform mat4 pMatrix;\n// light source\nuniform vec3 u_LightPos;\n// colours for different components\nuniform vec4 diffuse;\nuniform vec4 specular;\nuniform vec4 ambient;\nuniform float shininess;\n\n// the result colour will be passed to the fragment shader\nvarying vec4 v_Color;\n\n//main program for each vertex\nvoid main() {\n  // calculate the view space matrix\n  vec4 vertex_camSpace = vMatrix * mMatrix * vec4(vertex_worldSpace, 1.0);\n  // calculate the normals\n  vec4 normal_camSpace = vMatrix * mMatrix * vec4(normal_worldSpace, 0.0);\n  // project on to the scene\n  gl_Position = pMatrix * vertex_camSpace;\n\n  // the vector representing the direction of light\n  vec3 lightVector = normalize(u_LightPos - vec3(vertex_camSpace));\n  \n  float distance = length(u_LightPos - vec3(vertex_camSpace));\n  \n  float diffuse_val = max(dot(vec3(normal_camSpace), lightVector), 0.1);\n  diffuse_val = max(diffuse_val * (1.0 / (1.0 + (0.25 * distance * distance))) * 300.0, 0.1);\n\n  float reflect_light_dot = dot(normalize(reflect(lightVector, vec3(normal_camSpace))), normalize(vertex_camSpace.xyz));\n  float specular_val = pow(max(reflect_light_dot, 0.0), 0.3*shininess);\n\n  v_Color = vec4(diffuse * diffuse_val + specular * specular_val * 0.7 + ambient);\n}"},"fragment":{"source":"//for better performance less precision\nprecision mediump float;\nvarying vec4 v_Color;\n\n//main program for each fragment = pixel candidate\nvoid main() {\n  gl_FragColor = vec4(v_Color.xyz, 1.0);\n}"}},"uniforms":{"value":{"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"pMatrix":{"attachment":"Projection Matrix"},"u_LightPos":{"value":[0,0,10]},"diffuse":{"value":[1,0,0,1]},"specular":{"value":[1,1,1,1]},"ambient":{"value":[0.5,0,0,1]},"shininess":{"value":[10]}}}}},"Quad":{"R2T":{"shaders":{"vertex":{"source":"//vertex coordinates in world space for the render quad\nattribute vec3 vertex_worldSpace;\n//texture coordinate for this vertex and the render quad\nattribute vec2 textureCoordinate_input;\n\n//texture coordinate needs to be passed on to the R2T fragment shader\nvarying vec2 varyingTextureCoordinate;\n\n//main program for each vertex of the render quad\nvoid main() {\n  gl_Position = vec4(vertex_worldSpace, 1.0);\n  varyingTextureCoordinate = textureCoordinate_input;\n}"},"fragment":{"source":"precision mediump float;\n\n//a texture sampling unit, which is bound to the render quad texture buffer\nuniform sampler2D textureRendered;\n\n//texture coordinates coming from the vertex shader, interpolated through the rasterizer\nvarying vec2 varyingTextureCoordinate;\n\n//main program for each fragment of the render quad\nvoid main() {\n  gl_FragColor = texture2D(textureRendered, varyingTextureCoordinate.st);\n}"}},"uniforms":{"value":{"textureRendered":{"attachment":"Model/base Pass color"}}}}}},"output":{"image":"Quad/R2T Pass color"}}